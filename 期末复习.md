# 期末复习——基本语法+重温讲义+作业题目

2025/12/26 Lyq

### 读取输入

```python
# 1. 读取字符串
s = input()                    # 读取一行字符串
s = input().strip()           # 去掉首尾空白字符（最常用）

# 2. 读取单个整数
n = int(input())              # 读取整数
n = int(input().strip())      # 推荐：先去空白再转整数

# 3. 读取单个浮点数
x = float(input())            # 读取浮点数
x = float(input().strip())
# 一行包含多个值，用空格分隔
# 输入示例: "1 2 3"

# 方法1: split后分别转换
a, b, c = input().split()      # ['1', '2', '3']
a, b, c = int(a), int(b), int(c)

# 方法2: map转换
a, b, c = map(int, input().split())  # 最常用！

# 方法3: 直接转列表
nums = list(map(int, input().split()))  # [1, 2, 3]

# 方法4: 数量不确定时
values = input().split()  # 保持字符串
numbers = [int(x) for x in input().split()]  # 转整数列表
# 先读行数，再读n行
n = int(input())  # 第一行是行数
lines = []
for _ in range(n):
    line = input().strip()
    lines.append(line)
    # 1. 使用try-except
lines = []
while True:
    try:
        line = input()
        lines.append(line)
    except EOFError:  # 按Ctrl+D (Unix) 或 Ctrl+Z+Enter (Windows)
        break

# 2. 使用sys.stdin
import sys
lines = sys.stdin.read().splitlines()  # 读取所有行
lines = sys.stdin.readlines()          # 包含换行符
lines = [line.strip() for line in sys.stdin]  # 推荐
# 遇到空行时停止
lines = []
while True:
    line = input().strip()
    if not line:  # 空行
        break
    lines.append(line)
```

### 列表的语法

```python
# 创建空列表
lst1 = []                     # 推荐
lst2 = list()                # 同样创建空列表

# 创建有初始元素的列表
lst3 = [1, 2, 3, 4, 5]       # 整数列表
lst4 = ['a', 'b', 'c']       # 字符串列表
lst5 = [1, 'hello', 3.14, True]  # 混合类型列表
lst6 = [0] * 5               # 重复元素: [0, 0, 0, 0, 0]
lst7 = [i for i in range(5)]  # 列表推导式: [0, 1, 2, 3, 4]

# 从其他可迭代对象创建
lst8 = list("hello")         # ['h', 'e', 'l', 'l', 'o']
lst9 = list(range(5))        # [0, 1, 2, 3, 4]
lst10 = list((1, 2, 3))      # 从元组: [1, 2, 3]
lst = ['a', 'b', 'c', 'd', 'e']

# 索引访问（从0开始）
first = lst[0]      # 'a'
second = lst[1]     # 'b'
last = lst[-1]      # 'e'（倒数第一个）
second_last = lst[-2]  # 'd'

# 切片操作 [start:end:step]
sublist1 = lst[1:3]       # ['b', 'c']（包含1，不包含3）
sublist2 = lst[:3]         # ['a', 'b', 'c']（从头到3）
sublist3 = lst[2:]         # ['c', 'd', 'e']（从2到尾）
sublist4 = lst[::2]        # ['a', 'c', 'e']（步长为2）
sublist5 = lst[::-1]       # ['e', 'd', 'c', 'b', 'a']（反转列表）

# 检查元素存在
if 'a' in lst:
    print("'a' 在列表中")
    
# 获取索引
index = lst.index('c')     # 2（返回第一个匹配的索引）
# 注意：元素不存在会抛出 ValueError
index = lst.index('c', 0, 3)  # 在子范围[0,3)内查找
lst = [1, 2, 3, 4, 5]

# 修改单个元素
lst[0] = 10          # [10, 2, 3, 4, 5]
lst[-1] = 50         # [10, 2, 3, 4, 50]

# 修改切片
lst[1:3] = [20, 30]  # [10, 20, 30, 4, 50]
lst[2:4] = []        # 删除元素: [10, 20, 50]

# 添加元素
lst.append(6)        # 末尾添加: [10, 20, 50, 6]
lst.insert(1, 15)    # 在索引1处插入: [10, 15, 20, 50, 6]
lst.extend([7, 8, 9]) # 扩展列表: [10, 15, 20, 50, 6, 7, 8, 9]
lst += [10, 11]      # 用+号连接: ... 8, 9, 10, 11]

# 删除元素
removed = lst.pop()        # 删除并返回最后一个: 11
removed = lst.pop(1)       # 删除索引1处元素: 15
lst.remove(20)             # 删除第一个值为20的元素
del lst[0]                 # 删除索引0处元素
del lst[1:3]               # 删除切片
lst.clear()                # 清空列表: []

# 反转和排序
lst = [3, 1, 4, 1, 5, 9]
lst.reverse()              # 反转: [9, 5, 1, 4, 1, 3]
lst.sort()                 # 升序排序: [1, 1, 3, 4, 5, 9]
lst.sort(reverse=True)     # 降序排序: [9, 5, 4, 3, 1, 1]
new_sorted = sorted(lst)   # 返回新排序列表，不改变原列表
new_reversed = list(reversed(lst))  # 返回新反转列表
lst = [1, 2, 2, 3, 4, 2]

# 长度
length = len(lst)          # 6

# 计数
count = lst.count(2)        # 3（值为2的元素个数）

# 查找索引
index = lst.index(3)        # 3（元素3的索引）

# 复制列表
copy1 = lst.copy()         # 浅拷贝
copy2 = lst[:]             # 切片拷贝
copy3 = list(lst)          # 构造函数拷贝

# 合并列表
lst1 = [1, 2, 3]
lst2 = [4, 5, 6]
combined = lst1 + lst2     # [1, 2, 3, 4, 5, 6]
lst1.extend(lst2)          # lst1变为[1,2,3,4,5,6]

# 列表乘法
repeated = [0] * 5         # [0, 0, 0, 0, 0]
repeated = lst1 * 2        # 重复列表: [1,2,3,1,2,3]
# 基本形式
squares = [x**2 for x in range(5)]        # [0, 1, 4, 9, 16]

# 带条件的推导式
evens = [x for x in range(10) if x % 2 == 0]  # [0, 2, 4, 6, 8]

# 多个for循环
pairs = [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]

# 嵌套列表推导式
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [num for row in matrix for num in row]  # [1,2,3,4,5,6,7,8,9]

# 复杂表达式
result = [(x, x**2) for x in range(6)]  # [(0,0), (1,1), (2,4), ...]
```

### 栈

```python
# Python列表天然支持栈操作（后进先出LIFO）
stack = []                     # 创建空栈

# 入栈 (push) - 添加到末尾
stack.append(1)               # 栈: [1]
stack.append(2)               # 栈: [1, 2]
stack.append(3)               # 栈: [1, 2, 3]

# 出栈 (pop) - 从末尾移除
top = stack.pop()             # 返回3，栈: [1, 2]
top = stack.pop()             # 返回2，栈: [1]

# 查看栈顶 (peek) 而不弹出
if stack:
    top_item = stack[-1]      # 1（不弹出）

# 检查栈是否为空
is_empty = len(stack) == 0    # False
is_empty = not stack          # False

# 栈大小
size = len(stack)             # 1
class Stack:
    """栈的完整实现"""
    def __init__(self):
        self.items = []
    
    def push(self, item):
        """入栈"""
        self.items.append(item)
    
    def pop(self):
        """出栈"""
        if not self.is_empty():
            return self.items.pop()
        raise IndexError("pop from empty stack")
    
    def peek(self):
        """查看栈顶元素"""
        if not self.is_empty():
            return self.items[-1]
        raise IndexError("peek from empty stack")
    
    def is_empty(self):
        """判断栈是否为空"""
        return len(self.items) == 0
    
    def size(self):
        """返回栈的大小"""
        return len(self.items)
    
    def clear(self):
        """清空栈"""
        self.items.clear()
    
    def __str__(self):
        """字符串表示"""
        return f"Stack({self.items})"
    
    def __len__(self):
        """支持len()函数"""
        return len(self.items)

# 使用示例
stack = Stack()
stack.push(10)
stack.push(20)
stack.push(30)
print(stack.peek())   # 30
print(stack.pop())   # 30
print(len(stack))     # 2
print(stack)         # Stack([10, 20])
from collections import deque

# deque也可以作为栈使用（效率略高于list）
stack = deque()

# 入栈
stack.append(1)
stack.append(2)
stack.append(3)

# 出栈
stack.pop()  # 3

# 查看栈顶
if stack:
    top = stack[-1]  # 2

# 与list的不同：deque是线程安全的
```

### 一些细碎的知识

```python
# 常用ASCII范围
# 0-31: 控制字符
# 32-47: 标点符号 !"#$%&'()*+,-./
# 48-57: 数字 0-9
# 58-64: :;<=>?@
# 65-90: 大写字母 A-Z
# 91-96: [\]^_`
# 97-122: 小写字母 a-z
# 123-126: {|}~

# 字符与ASCII码互转
char = 'A'
ascii_code = ord('A')        # 65
char_from_code = chr(65)     # 'A'

# 常用字符的ASCII码
print(ord('0'))     # 48
print(ord('9'))     # 57
print(ord('A'))     # 65
print(ord('Z'))     # 90
print(ord('a'))     # 97
print(ord('z'))     # 122
print(ord(' '))     # 32（空格）
print(ord('\n'))    # 10（换行）

s = "Hello123!"

# 字符类型判断
print('H'.isalpha())     # True 是否是字母
print('5'.isdigit())     # True 是否是数字(0-9)
print('5'.isnumeric())   # True 是否是数字字符(包括中文数字)
print('Ⅳ'.isnumeric())   # True 罗马数字4
print('a'.islower())     # True 是否小写
print('A'.isupper())     # True 是否大写
print('Hello'.istitle()) # True 是否每个单词首字母大写
print(' \t\n'.isspace()) # True 是否空白字符
print('abc123'.isalnum())# True 是否字母或数字
print('hello'.isascii()) # True 是否ASCII字符

# 实用函数
def is_printable_ascii(c):
    """判断是否可打印ASCII字符"""
    return 32 <= ord(c) <= 126
text = "Hello World 123"

# 基本转换
print(text.upper())       # HELLO WORLD 123
print(text.lower())       # hello world 123
print(text.title())       # Hello World 123
print(text.capitalize())  # Hello world 123
print(text.swapcase())    # hELLO wORLD 123

# 每个单词首字母大写
print("hello world".title())         # Hello World
print("they're friends".title())     # They'Re Friends (注意！)
# 不同进制的表示
binary = 0b1010      # 二进制: 10
octal = 0o12         # 八进制: 10
hexadecimal = 0xA    # 十六进制: 10
decimal = 10         # 十进制: 10

# 进制转换函数
num = 42

# 转换为不同进制的字符串
bin_str = bin(num)       # '0b101010' 二进制
oct_str = oct(num)       # '0o52'     八进制
hex_str = hex(num)       # '0x2a'     十六进制

# 去掉前缀
bin_str_no_prefix = bin(num)[2:]     # '101010'
hex_str_no_prefix = hex(num)[2:]     # '2a'

# 字符串转整数（指定进制）
print(int('101010', 2))    # 42
print(int('52', 8))        # 42
print(int('2A', 16))       # 42
print(int('2a', 16))       # 42（不区分大小写）

# 格式化输出
print(f"{num:b}")   # 101010
print(f"{num:o}")   # 52
print(f"{num:x}")   # 2a
print(f"{num:X}")   # 2A
print(f"{num:#b}")  # 0b101010
print(f"{num:#o}")  # 0o52
print(f"{num:#x}")  # 0x2a


import math

# 常数
print(math.pi)      # 3.141592653589793
print(math.e)       # 2.718281828459045
print(math.tau)     # 6.283185307179586 (2π)
print(math.inf)     # inf
print(math.nan)     # nan

# 幂和对数
print(math.pow(2, 3))    # 8.0
print(math.sqrt(16))      # 4.0
print(math.exp(1))        # e ≈ 2.718
print(math.log(10))       # 自然对数 ≈ 2.302
print(math.log10(100))    # 2.0
print(math.log2(8))       # 3.0

# 三角函数（参数是弧度）
angle_rad = math.radians(30)  # 角度转弧度
angle_deg = math.degrees(math.pi/6)  # 弧度转角度
print(math.sin(math.pi/2))  # 1.0
print(math.cos(0))          # 1.0
print(math.tan(math.pi/4))  # 1.0

# 取整函数
print(math.ceil(3.2))     # 4（向上取整）
print(math.floor(3.8))    # 3（向下取整）
print(math.trunc(-3.2))    # -3（向零取整）
print(round(3.14159, 2))   # 3.14（四舍五入，内置函数）

# 绝对值
print(math.fabs(-5.5))     # 5.5（返回浮点数）
print(abs(-5.5))           # 5.5（内置函数，保持类型）

# 最大公约数和最小公倍数
print(math.gcd(12, 18))    # 6
print(math.lcm(12, 18))    # 36（Python 3.9+）

# 阶乘
print(math.factorial(5))   # 120

# 组合与排列
print(math.comb(5, 2))     # 10（C(5,2)）
print(math.perm(5, 2))     # 20（P(5,2)）

# 距离和角度
print(math.hypot(3, 4))    # 5.0（欧几里得距离）
```

### 多种输出方法

```python
# 基本输出
print("Hello, World!")

# 输出多个值（自动用空格分隔）
name = "张三"
age = 20
print("姓名:", name, "年龄:", age)  # 输出: 姓名: 张三 年龄: 20

# 修改分隔符
print("2024", "12", "25", sep="-")  # 输出: 2024-12-25

# 修改结束符（默认是换行）
print("Hello", end=" ")  # 不换行
print("World")  # 输出: Hello World

# 2. str.format() 方法
print("学生: {}, 分数: {:.2f}".format(name, score))
print("学生: {0}, 分数: {1:.2f}".format(name, score))  # 带索引
print("学生: {name}, 分数: {score:.2f}".format(name=name, score=score))

name = "王五"
age = 25
score = 88.8888

# 基本用法
print(f"姓名: {name}, 年龄: {age}")  # 输出: 姓名: 王五, 年龄: 25

# 数字格式化
print(f"分数: {score:.2f}")    # 保留2位小数: 分数: 88.89
print(f"分数: {score:.0f}")    # 无小数: 分数: 89
print(f"百分比: {0.4567:.1%}")  # 百分比: 45.7%

# 对齐和填充
print(f"姓名: {name:<10} 年龄: {age}")  # 左对齐，宽度10
print(f"分数: {score:>10.2f}")         # 右对齐，宽度10
print(f"分数: {score:^10.2f}")         # 居中对齐
print(f"分数: {score:*>10.2f}")        # 右侧*填充: *****88.89

# 表达式计算
a, b = 10, 3
print(f"{a} + {b} = {a + b}")  # 输出: 10 + 3 = 13
print(f"{a} / {b} = {a / b:.2f}")  # 输出: 10 / 3 = 3.33

my_list = [1, 2, 3, 4, 5]

# 1. 直接打印列表
print(my_list)  # 输出: [1, 2, 3, 4, 5]

# 2. 遍历输出每个元素
for item in my_list:
    print(item)  # 每个元素一行

# 3. 不带中括号的输出
print(*my_list)  # 输出: 1 2 3 4 5
print(*my_list, sep=", ")  # 输出: 1, 2, 3, 4, 5

# 4. 用join（仅适用于字符串元素）
str_list = ["apple", "banana", "cherry"]
print(", ".join(str_list))  # 输出: apple, banana, cherry

# 5. 数字列表转字符串列表输出
num_list = [1.1, 2.2, 3.3]
# 方法1: map + join
print(", ".join(map(str, num_list)))  # 输出: 1.1, 2.2, 3.3
# 方法2: 列表推导式
print(", ".join([f"{x:.2f}" for x in num_list]))  # 输出: 1.10, 2.20, 3.30

# 6. 带索引的输出
for i, item in enumerate(my_list, 1):  # 从1开始计数
    print(f"{i}. {item}")
# 输出:
# 1. 1
# 2. 2
# 3. 3
# ...

# 7. 格式化输出列表中的数字
prices = [12.5, 9.99, 23.456, 5.0]
for price in prices:
    print(f"¥{price:>8.2f}")  # 右对齐，宽度8，保留2位小数
# 输出:
# ¥   12.50
# ¥    9.99
# ¥   23.46
# ¥    5.00

num = 123.456789

# 保留2位小数
print(f"{num:.2f}")    # 123.46 (四舍五入)
print(round(num, 2))   # 123.46 (返回浮点数)
print("{:.2f}".format(num))  # 123.46

# 保留整数
print(f"{num:.0f}")    # 123
print(round(num))      # 123

# 科学计数法
print(f"{num:.2e}")    # 1.23e+02

# 百分比
percent = 0.4567
print(f"{percent:.1%}")  # 45.7%
print(f"{percent:.2%}")  # 45.67%

# 补零对齐
num2 = 7.5
print(f"{num2:08.2f}")  # 00007.50 (总宽度8，不足补0)
# 使用示例
scores = [95.5, 88.3, 92.7, 76.4]
print_list(scores, fmt="{:.1f}")  # 输出: 95.5, 88.3, 92.7, 76.4
```

### 队列

```python
from collections import deque  # 双端队列，常用作队列

# 创建队列
queue = deque()  # 空队列
queue = deque([1, 2, 3])  # 从列表初始化
queue = deque(maxlen=5)  # 最大长度限制

# 基本操作
queue.append(4)       # 入队: 从右侧添加
queue.appendleft(0)   # 从左侧添加
item = queue.popleft()  # 出队: 从左侧弹出（队列标准操作）
item = queue.pop()    # 从右侧弹出

# 查看
front = queue[0]      # 查看队首（不移除）
rear = queue[-1]      # 查看队尾
length = len(queue)   # 队列长度
is_empty = len(queue) == 0  # 判断是否为空

# 其他操作
queue.clear()         # 清空队列
queue.remove(2)       # 删除指定元素
queue.rotate(2)       # 向右旋转2步
queue.rotate(-1)      # 向左旋转1步
queue.extend([5, 6])  # 从右侧批量添加
queue.extendleft([-1, 0])  # 从左侧批量添加
```

### 矩阵

```python
# 创建矩阵
matrix = [[1, 2, 3],
          [4, 5, 6],
          [7, 8, 9]]  # 3x3 矩阵

# 访问元素
val = matrix[1][2]  # 第2行第3列 → 6
row = matrix[1]     # 获取第2行 → [4, 5, 6]

# 遍历矩阵
# 1. 逐行遍历
for row in matrix:
    for val in row:
        print(val, end=' ')
    print()

# 2. 通过索引遍历
rows = len(matrix)
cols = len(matrix[0])
for i in range(rows):
    for j in range(cols):
        print(f"matrix[{i}][{j}] = {matrix[i][j]}")

# 3. 使用 enumerate
for i, row in enumerate(matrix):
    for j, val in enumerate(row):
        print(f"({i},{j}): {val}")

# 创建特殊矩阵
zeros = [[0] * cols for _ in range(rows)]  # 零矩阵
ones = [[1] * cols for _ in range(rows)]   # 全1矩阵
identity = [[1 if i==j else 0 for j in range(3)] for i in range(3)]  # 单位矩阵

# 转置矩阵
def transpose(matrix):
    return [[matrix[j][i] for j in range(len(matrix))] 
            for i in range(len(matrix[0]))]

# 矩阵相加（同维度）
def add_matrices(a, b):
    return [[a[i][j] + b[i][j] for j in range(len(a[0]))] 
            for i in range(len(a))]

# 矩阵相乘
def multiply_matrices(a, b):
    if len(a[0]) != len(b):
        raise ValueError("矩阵维度不匹配")
    result = [[0] * len(b[0]) for _ in range(len(a))]
    for i in range(len(a)):
        for j in range(len(b[0])):
            for k in range(len(b)):
                result[i][j] += a[i][k] * b[k][j]
    return result
```

### 字典

```python
# 创建字典
d1 = {}                     # 空字典
d2 = {'a': 1, 'b': 2, 'c': 3}
d3 = dict(a=1, b=2, c=3)    # 关键字参数创建
d4 = dict([('a', 1), ('b', 2)])  # 可迭代对象创建
d5 = dict.fromkeys(['a', 'b', 'c'], 0)  # 相同值初始化 → {'a':0, 'b':0, 'c':0}

# 访问元素
value = d2['a']        # 通过键访问 → 1
value = d2.get('a')    # 通过get访问 → 1
value = d2.get('d', 0) # 键不存在返回默认值 → 0

# 修改/添加元素
d2['a'] = 10           # 修改已存在的键
d2['d'] = 4            # 添加新键值对
d2.update({'e': 5, 'f': 6})  # 批量更新

# 删除元素
del d2['a']            # 删除键'a'
value = d2.pop('b')    # 删除并返回值 → 2
item = d2.popitem()    # 删除最后一项并返回 (key, value)
d2.clear()             # 清空字典
my_dict = {'a': 1, 'b': 2, 'c': 3}

# 遍历键
for key in my_dict:
    print(key)
for key in my_dict.keys():  # 显式调用keys()
    print(key)

# 遍历值
for value in my_dict.values():
    print(value)

# 遍历键值对
for key, value in my_dict.items():
    print(f"{key}: {value}")

# 带索引的遍历
for i, (key, value) in enumerate(my_dict.items()):
    print(f"{i}. {key}: {value}")

# 创建字典
squares = {x: x**2 for x in range(5)}  # {0:0, 1:1, 2:4, 3:9, 4:16}

# 过滤
even_squares = {k: v for k, v in squares.items() if k % 2 == 0}

# 转换
prices = {'apple': 1.2, 'banana': 0.8, 'orange': 1.5}
prices_with_tax = {k: v*1.1 for k, v in prices.items()}

# 合并两个列表为字典
keys = ['a', 'b', 'c']
values = [1, 2, 3]
d = {k: v for k, v in zip(keys, values)}  # {'a':1, 'b':2, 'c':3}

# 检查键是否存在
if 'a' in my_dict:
    print("键存在")

# 获取所有键/值/键值对
keys = list(my_dict.keys())      # ['a', 'b', 'c']
values = list(my_dict.values())  # [1, 2, 3]
items = list(my_dict.items())    # [('a',1), ('b',2), ('c',3)]

# 设置默认值
my_dict.setdefault('d', 0)  # 如果'd'不存在，设置为0

# 合并字典
d1 = {'a': 1, 'b': 2}
d2 = {'b': 3, 'c': 4}
merged = {**d1, **d2}  # Python 3.5+, {'a':1, 'b':3, 'c':4}
merged = d1 | d2       # Python 3.9+, 同上
merged = d1.copy()
merged.update(d2)      # 更新方式合并
# 按键排序
sorted_by_key = dict(sorted(my_dict.items()))  # 默认按键排序
sorted_by_key = dict(sorted(my_dict.items(), key=lambda x: x[0]))

# 按值排序
sorted_by_value = dict(sorted(my_dict.items(), key=lambda x: x[1]))

# 按值降序排序
sorted_desc = dict(sorted(my_dict.items(), key=lambda x: x[1], reverse=True))

# 复杂排序示例
data = {'Alice': 25, 'Bob': 30, 'Charlie': 20}
# 按年龄排序
sorted_by_age = dict(sorted(data.items(), key=lambda x: x[1]))
# 创建嵌套字典
students = {
    'Alice': {'age': 20, 'score': 95},
    'Bob': {'age': 22, 'score': 88},
    'Charlie': {'age': 21, 'score': 92}
}

# 访问嵌套值
alice_age = students['Alice']['age']  # 20
bob_score = students.get('Bob', {}).get('score', 0)  # 88

# 修改嵌套值
students['Alice']['score'] = 96
students['David'] = {'age': 23, 'score': 85}  # 添加新学生

# 遍历嵌套字典
for name, info in students.items():
    print(f"{name}: 年龄={info['age']}, 分数={info['score']}")
```

![image-20251225104555444](C:\Users\Katherine Lee\AppData\Roaming\Typora\typora-user-images\image-20251225104555444.png)

### week8-9

### 4.3 递归三部曲：全排列

#### 示例sy132: 全排列I 中等

https://sunnywhy.com/sfbj/4/3/132

```python
# 初始化访问标记数组，长度为11（因为n最大为10，索引从1开始使用更方便）
table = [False] * 11
# 读取输入的n，表示要生成1到n的全排列
n = int(input())
# 递归函数，生成全排列
def solve(n, prefix=[]):
    # 如果当前前缀长度已经等于n，说明已经生成了一个完整的排列
    if len(prefix) == n:
        return [prefix]  # 返回当前排列，包装在列表中以便后续拼接
    result = []  # 用于存储所有子排列的结果
    # 遍历1到n的所有数字
    for i in range(1, 1 + n):
        if table[i]:  # 如果数字i已经被使用过，则跳过
            continue
        table[i] = True  # 标记数字i为已使用
        # 递归生成剩余数字的排列，并将当前数字i添加到前缀中
        result += solve(n, prefix + [i])
        table[i] = False  # 回溯：取消标记，以便其他排列可以使用这个数字
    return result  # 返回所有可能的排列
# 调用函数生成全排列
result = solve(n)
# 遍历并输出所有排列
for r in result:
    # 将排列中的数字转换为字符串并用空格连接，然后打印
    print(' '.join(map(str, r)))
```

### 练习02386: Lake Counting

dfs similar, http://cs101.openjudge.cn/practice/02386

```python
#1.dfs
import sys
sys.setrecursionlimit(20000)
def dfs(x,y):
	#标记，避免再次访问
    field[x][y]='.'
    for k in range(8):
        nx,ny=x+dx[k],y+dy[k]
        #范围内且未访问的lake
        if 0<=nx<n and 0<=ny<m\
                and field[nx][ny]=='W':
            #继续搜索
            dfs(nx,ny)
n,m=map(int,input().split())
field=[list(input()) for _ in range(n)]
cnt=0
dx=[-1,-1,-1,0,0,1,1,1]
dy=[-1,0,1,-1,1,-1,0,1]
for i in range(n):
    for j in range(m):
        if field[i][j]=='W':
            dfs(i,j)
            cnt+=1
print(cnt)
```

### 练习M05585: 晶矿的个数

matrices, dfs similar, http://cs101.openjudge.cn/pctbook/M05585

```python
dir = [[-1,0],[1,0],[0,1],[0,-1]]
def dfs(x, y, c):
    m[x][y] = '#'
    for i in range(len(dir)):
        tx = x + dir[i][0]
        ty = y + dir[i][1]
        if m[tx][ty] == c:
            dfs(tx, ty, c)
for _ in range(int(input())):
    n = int(input())
    m = [[0 for _ in range(n + 2)] for _ in range(n + 2)]
    for i in range(1, n + 1):
        m[i][1:-1] = input()
    r = 0; b = 0
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if m[i][j] == 'r':
                dfs(i, j, "r")
                r += 1
            if m[i][j] == 'b':
                dfs(i, j, "b")
                b += 1
    print(r, b)
```

### 练习02754: 八皇后

dfs and similar, http://cs101.openjudge.cn/pctbook/T02754

```python
def solve_n_queens(n):
    solutions = []  # 存储所有解决方案的列表
    queens = [-1] * n  # 存储每一行皇后所在的列数
    
    def backtrack(row):
        if row == n:  # 找到一个合法解决方案
            solutions.append(queens.copy())
        else:
            for col in range(n):
                if is_valid(row, col):  # 检查当前位置是否合法
                    queens[row] = col  # 在当前行放置皇后
                    backtrack(row + 1)  # 递归处理下一行
                    queens[row] = -1  # 回溯，撤销当前行的选择
    
    def is_valid(row, col):
        for r in range(row):
            if queens[r] == col or abs(row - r) == abs(col - queens[r]):
                return False
        return True
    
    backtrack(0)  # 从第一行开始回溯
    
    return solutions


# 获取第 b 个皇后串
def get_queen_string(b):
    solutions = solve_n_queens(8)
    if b > len(solutions):
        return None
    queen_string = ''.join(str(col + 1) for col in solutions[b - 1])
    return queen_string


test_cases = int(input())  # 输入的测试数据组数
for _ in range(test_cases):
    b = int(input())  # 输入的 b 值
    queen_string = get_queen_string(b)
    print(queen_string)
```

another solution:

```python
ans = []
def queen_dfs(A, cur=0):          #考虑放第cur行的皇后
    if cur == len(A):             #如果已经放了n个皇后，一组新的解产生了
        ans.append(''.join([str(x+1) for x in A])) #注意避免浅拷贝
        return 
    
    for col in range(len(A)):     #将当前皇后逐一放置在不同的列，每列对应一组解
        for row in range(cur):    #逐一判定，与前面的皇后是否冲突
            #因为预先确定所有皇后一定不在同一行，所以只需要检查是否同列，或者在同一斜线上
            if A[row] == col or abs(col - A[row]) == cur - row:
                break
        else:                     #若都不冲突
            A[cur] = col          #放置新皇后，在cur行，col列
            queen_dfs(A, cur+1)	  #对下一个皇后位置进行递归
            
queen_dfs([None]*8)   
for _ in range(int(input())):
    print(ans[int(input()) - 1])
```

```python
优化
import sys
from functools import lru_cache

# 设置递归深度限制
sys.setrecursionlimit(1 << 30)

# 使用 lru_cache 缓存中间结果
@lru_cache(maxsize=None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

# 测试
print(fibonacci(35))  # 现在会非常快
```

递归复习法：http://wjjc.openjudge.cn/2024jgc5/002/

```python
from functools import lru_cache
import sys
@lru_cache(maxsize=None)
def study_time(n):
    if n == 1 or n == 2:
        return n
    return n + study_time(n - 1) + study_time(n - 2)
if __name__ == "__main__":
    # 读取所有输入
    input_data = sys.stdin.read().strip()
    data = input_data.split()
    m = int(data[0])
    results = []
    for i in range(1, m + 1):
        n = int(data[i])
        results.append(study_time(n))
    for result in results:
        print(result)
```

### 示例sy132: 全排列

https://sunnywhy.com/sfbj/4/3/132

给定一个正整数 n，假设序列 S = [1,2,3,...,n]，求 S 的全排列。

```python
# 读取输入的正整数n
n = int(input())
# 初始化列表l，用于存储1到n的字符串形式
l = []
# 循环生成1到n的字符串，并添加到列表l中
for i in range(1, n + 1):
    l.append(f'{i}')  # 将数字转换为字符串，如'1', '2', ... 'n'

# 定义生成排列的生成器函数
def arrange(l):
    # 基准情况：如果列表只有一个元素，直接返回这个元素
    if len(l) == 1:
        yield l[0]  # 生成唯一的排列
    else:
        # 遍历列表中的每个元素作为排列的第一个元素
        for i in range(len(l)):
            # 创建新列表，包含除当前元素外的所有元素
            new_l = l[:i] + l[i+1:]  # 切片操作，排除索引i处的元素
            # 递归生成剩余元素的所有排列
            for rest in arrange(new_l):
                # 将当前元素与剩余元素的排列组合，中间用空格连接
                yield l[i] + ' ' + rest  # 生成完整的排列

# 遍历生成器生成的所有排列并打印
for ans in arrange(l):
    print(ans)  # 输出一个完整的排列
```

## M46.全排列

backtracking, https://leetcode.cn/problems/permutations/

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

```python
class Solution:
    def permute(self, nums):
        n = len(nums)
        ans, sol = [], []
        
        def backtrack():
            # 终止条件：当前排列已满
            if len(sol) == n:
                ans.append(sol[:])  # 深拷贝
                return
            
            # 尝试每个未被使用的数
            for x in nums:
                if x not in sol:        # 剪枝：避免重复使用
                    sol.append(x)       # 选择
                    backtrack()         # 递归
                    sol.pop()           # 回溯
        
        backtrack()
        return ans
```

AI给的另外一种方法：

```python
def permute(self, nums):
    n = len(nums)
    ans, col = [], []
    visited = [False] * n  # 用布尔数组记录访问状态，O(1)检查
    def backtrack():
        if len(col) == n:
            ans.append(col[:])
            return
        for i in range(n):
            if not visited[i]:  # 用索引检查，避免值重复的问题
                visited[i] = True
                col.append(nums[i])
                backtrack()
                col.pop()
                visited[i] = False
    backtrack()
    return ans
```



## 练习sy134: 全排列III 中等

https://sunnywhy.com/sfbj/4/3/134

给定一个长度为的序列，其中有个可能重复的正整数，求该序列的所有全排列。

```python
# 导入类型提示
from typing import List

class Solution:
    def permute(self, nums):
        n = len(nums)  # 获取输入列表的长度
        # 使用集合存储结果，可以自动去重
        ans, sol = set(), []  # ans: 最终结果集合，sol: 当前排列
        used = [False] * n  # 标记数组，记录每个元素是否已被使用
        
        # 回溯函数
        def backtrack():
            # 如果当前排列长度等于n，说明找到一个完整排列
            if len(sol) == n:
                ans.add(tuple(sol))  # 将列表转为元组并加入集合（元组可哈希）
                return
            
            # 遍历所有元素
            for i in range(n):
                if used[i]:  # 如果当前元素已被使用，跳过
                    continue
                # 关键剪枝：避免重复排列
                # 条件：当前元素和前一个元素相同，且前一个元素已被使用过
                # 这样可以确保相同元素的相对顺序固定，避免生成重复排列
                if i > 0 and nums[i] == nums[i-1] and used[i-1]:
                    continue
                
                # 选择当前元素
                used[i] = True
                sol.append(nums[i])
                
                # 递归进入下一层
                backtrack()
                
                # 撤销选择（回溯）
                sol.pop()
                used[i] = False
        
        nums.sort()  # 先排序，方便后续剪枝去重
        backtrack()  # 开始回溯
        return ans  # 返回所有排列的集合

# 主程序
if __name__ == '__main__':
    sol = Solution()  # 创建Solution对象
    n = int(input())  # 读取序列长度
    a = list(map(int, input().split()))  # 读取序列元素
    result = sol.permute(a)  # 获取全排列结果
    # 对结果排序后输出（集合无序，需要排序保证输出顺序）
    for perm in sorted(result):  # sorted默认按元组顺序排序
        print(*perm)  # 解包元组，用空格分隔输出
```

## 练习M78.子集

backtracking, https://leetcode.cn/problems/subsets/

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

```python
class Solution:
    def solve(self, nums):
        n = len(nums)
        ans, sol = [], []
        def backtrack(i):
            if i == n:
                ans.append(tuple(sol))
                return
            backtrack(i + 1)
            sol.append(nums[i])
            backtrack(i + 1)
            sol.pop()
        backtrack(0)
        return ans
```

```
backtrack(0)
├── backtrack(1)  # 不选1
│   ├── backtrack(2)  # 不选1,2
│   │   ├── backtrack(3)  # 不选1,2,3 → [] ✓
│   │   └── 选3 → [3] ✓
│   └── 选2 → backtrack(2)
│       ├── backtrack(3)  # 选2 → [2] ✓
│       └── 选3 → [2, 3] ✓
└── 选1 → backtrack(1)
    ├── backtrack(2)  # 选1, 不选2
    │   ├── backtrack(3)  # 选1 → [1] ✓
    │   └── 选3 → [1, 3] ✓
    └── 选2 → backtrack(2)
        ├── backtrack(3)  # 选1,2 → [1, 2] ✓
        └── 选3 → [1, 2, 3] ✓
```

## M131.分割回文串

dp, backtracking, https://leetcode.cn/problems/palindrome-partitioning/

```python
from functools import lru_cache
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)
        ans = []
        @lru_cache(None)
        def is_pal(i, j):
            return i >= j or (s[i] == s[j] and is_pal(i + 1, j - 1))

        def dfs(start, path):
            if start == n:
                ans.append(path[:])
                return
            for end in range(start, n):
                if is_pal(start, end):
                    path.append(s[start:end + 1])
                    dfs(end + 1, path)
                    path.pop()
        dfs(0, [])
        return ans
```

### 晴问9.6.1 学校的班级个数（1）

https://sunnywhy.com/sfbj/9/6/360

```python
def find(x):
    if parent[x] != x: # 如果不是根结点，继续循环
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    parent[find(x)] = find(y)

n, m = map(int, input().split())
parent = list(range(n + 1))	# parent[i] == i，则说明元素i是该集合的根结点

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

classes = set(find(x) for x in range(1, n + 1))
print(len(classes))
```

###  M56.合并区间

https://leetcode.cn/problems/merge-intervals/

```python
from typing import List
import sys

class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        res = []
        st, ed = -sys.maxsize, -sys.maxsize
        for v in intervals:
            if ed == -sys.maxsize:
                st, ed = v[0], v[1]
            elif v[0] <= ed:
                ed = max(ed, v[1])
            elif v[0] > ed:
                res.append([st, ed])
                st, ed = v[0], v[1]
        if ed != -sys.maxsize:
            res.append([st, ed])
        return res
```

### 晴问9.6.4 迷宫连通性

https://sunnywhy.com/sfbj/9/6/363

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    parent[find(x)] = find(y)

n, m = map(int, input().split())
parent = list(range(n + 1))

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

sets = set(find(x) for x in range(1, n + 1))
if len(sets) == 1:
    print('Yes')
else:
    print('No')
```

### 晴问9.6.5 班级最高分

https://sunnywhy.com/sfbj/9/6/364

```python
# 读取学生人数和关系数
n, m = map(int, input().split())
# 读取学生分数列表（索引0对应学生1的分数）
scores = list(map(int, input().split()))
# 初始化并查集，每个学生初始时自成一个班级
parent = list(range(n + 1))

# 查找根节点函数（带路径压缩）
def find(x):
    if parent[x] != x:
        # 路径压缩：在查找过程中将节点直接指向根节点
        parent[x] = find(parent[x])
    return parent[x]

# 合并两个学生所在的班级
def union(x, y):
    # 将x所在班级合并到y所在班级
    parent[find(x)] = find(y)

# 处理所有学生关系，合并班级
for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

# 统计每个班级的最高分
class_max = {}
for i in range(1, n + 1):
    root = find(i)  # 找到学生i所在班级的根节点
    if root not in class_max:
        # 如果该班级还没记录最高分，直接记录当前学生分数
        class_max[root] = scores[i - 1]
    else:
        # 如果已有记录，取最大值
        class_max[root] = max(class_max[root], scores[i - 1])

# 输出班级个数
print(len(class_max))
# 输出每个班级的最高分（按降序排列）
print(' '.join(map(str, sorted(class_max.values(), reverse=True))))
```

### week10~11

### 练习LC M56.合并区间

```python
from typing import List
import sys

class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        # 首先按照区间的起始位置进行排序
        intervals.sort()

        # 初始化结果列表
        res = []
        # 初始化当前合并区间的起始和结束位置，用负无穷表示未开始
        st, ed = -sys.maxsize, -sys.maxsize
        
        # 遍历排序后的所有区间
        for v in intervals:
            # 如果是第一个区间，直接设置为当前合并区间
            if ed == -sys.maxsize:
                st, ed = v[0], v[1]
            # 如果当前区间与合并区间有重叠（当前区间的起始 <= 合并区间的结束）
            elif v[0] <= ed:
                # 更新合并区间的结束位置（取最大值）
                ed = max(v[1], ed)
            # 如果当前区间与合并区间没有重叠
            elif v[0] > ed:
                # 将之前的合并区间加入结果列表
                res.append([st, ed])
                # 开始新的合并区间
                st, ed = v[0], v[1]

        # 处理最后一个合并区间（如果存在）
        if ed != -sys.maxsize:
            res.append([st, ed])

        return res
```

### M29947:校门外的树又来了

greedy, interval merging, stack, http://cs101.openjudge.cn/practice/29947/

```python
# 读取马路长度L和区域数量M
L, M = map(int, input().split())
# 初始化区间列表
intervals = []
# 读取M个区域
for _ in range(M):
    # 读取每个区域的起点和终点
    s, e = map(int, input().split())
    # 确保起点小于终点（处理输入可能无序的情况）
    if s > e:
        s, e = e, s
    # 将区间添加到列表中
    intervals.append((s, e))
# 按起点进行排序
intervals.sort()
# 初始化合并后的区间列表
merged = []
# 遍历所有区间进行合并
for s, e in intervals:
    # 如果合并列表为空，或者当前区间与最后一个合并区间不连续（有间隔）
    if not merged or s > merged[-1][1] + 1:
        # 直接添加新区间
        merged.append([s, e])
    else:
        # 否则合并区间，更新最后一个区间的终点
        merged[-1][1] = max(merged[-1][1], e)
# 计算被砍掉的树的总数（每个区间包含的树数）
cut = sum(e - s + 1 for s, e in merged)
# 计算剩余的树数（总树数 - 被砍树数）
remain = (L + 1) - cut

# 输出剩余的树数
print(remain)
```

### 2 选择不相交区间

**选择不相交区间问题**大概题意就是：

给出一堆区间，要求选择**尽量多**的区间，使得这些区间**互不相交**，求可选取的区间的**最大数量**。这里端点相同也算有重复。

```python
from typing import List
import sys

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        # 按照右端点从小到大排序
        # 这是贪心算法的关键：总是选择结束时间最早的区间
        intervals.sort(key=lambda x: x[1])

        res = 0  # 记录最多能选出的不重叠区间数量
        ed = -sys.maxsize  # 初始化结束时间为负无穷
        
        for v in intervals:
            # 如果当前区间的开始时间 >= 上一个选中区间的结束时间
            if ed <= v[0]:
                res += 1  # 可以选择这个区间
                ed = v[1]  # 更新结束时间

        # 需要移除的区间 = 总区间数 - 最多可保留的不重叠区间数
        return len(intervals) - res
```

## 3 区间选点问题

**区间选点问题**大概题意就是：

给出一堆区间，取**尽量少**的点，使得每个区间内**至少有一个点**（不同区间内含的点可以是同一个，位于区间端点上的点也算作区间内）。和上一题一样。

## 4 区间覆盖问题

给出一堆区间和一个目标区间，问最少选择多少区间可以**覆盖**掉题中给出的这段目标区间。

解题步骤：按照区间左端点从小到大排序、**从前往后**依次枚举每个区间，在所有能覆盖当前目标区间起始位置start的区间之中，选择**右端点**最大的区间。假设右端点最大的区间是第$i$个区间，右端点为 $r_i$。最后将目标区间的start更新成$r_i$

```python
from typing import List
class Solution:
    def videoStitching(self, clips: List[List[int]], time: int) -> int:
        # 对 clips 按起点升序排序
        clips.sort()
        st, ed = 0, time
        res = 0
        i = 0
        while i < len(clips) and st < ed:
            maxR = 0
            while i < len(clips) and clips[i][0] <= st:
                maxR = max(maxR, clips[i][1])
                i += 1
            if maxR <= st:
                return -1
            # 更新 st 为 maxR，并增加结果计数
            st = maxR
            res += 1
            if maxR >= ed:
                # 已经覆盖到终点
                return res
        # 如果没有成功覆盖到终点
        return -1写这个程序的解释，顺便删掉多余的空行
```

世界杯只因

```python
n = int(input())
a = list(map(int, input().split()))

# 1. 计算每个位置的覆盖区间
intervals = []
for i, x in enumerate(a, start=1):
    left = max(1, i - x)
    right = min(n, i + x)
    intervals.append((left, right))

# 2. 按左端点排序
intervals.sort()

# 3. 贪心选择最少区间覆盖 [1, N]
ans = 0
i = 0
covered = 0

while covered < n:
    best = covered
    # 在所有能接上的区间中，选右端点最大的
    while i < n and intervals[i][0] <= covered + 1:
        best = max(best, intervals[i][1])
        i += 1
    if best == covered:  # 无法延伸
        break
    covered = best
    ans += 1

print(ans)
```

最优解法

```python
n = int(input())  # 读取整数n
a = list(map(int, input().split()))  # 读取n个整数到列表a

# far[i] 表示：以i为左端点的区间，能够覆盖到的最远右端点
# 初始化长度为n+2，索引从1开始使用，多2是为了防止越界
far = [0] * (n + 2)

# enumerate(a, start=1)：遍历列表a，同时获取索引i和元素x
# i从1开始计数（因为题目位置从1开始）
# x是每个位置的跳跃距离
for i, x in enumerate(a, start=1):
    L = max(1, i - x)  # 从当前位置向左跳x步的最左位置，不能小于1
    R = min(n, i + x)  # 从当前位置向右跳x步的最右位置，不能大于n
    # 重要：far[L]记录从位置L开始，能到达的最远位置
    # 如果多个位置都能从L开始，取最大的R
    far[L] = max(far[L], R)

ans = 0      # 需要选择的最小点数
covered = 0  # 当前已覆盖的最右位置
best = 0     # 当前可到达的最远位置

# 遍历每个位置
for i in range(1, n + 1):
    best = max(best, far[i])  # 更新当前可到达的最远位置
    
    # 如果当前位置i超过了已覆盖范围
    if i > covered:
        ans += 1        # 需要在此位置之前选择一个点
        covered = best  # 更新已覆盖范围为当前可到达的最远位置

print(ans)
```

**建议**

今后遇到类似题型（如“最少灯照亮道路”“覆盖线段”等），
直接记下面这两种模板：

- **排序版**：适合任意输入区间。
- **线性版**：适合“按位置定义区间”的题。

#### 5 区间分组问题

给出一堆区间，问最少可以将这些区间分成多少组使得每个组内的区间互不相交。

主持人调度

```python
from typing import List

class Solution:
    def minmumNumberOfHost(self, n: int, startEnd: List[List[int]]) -> int:
        # 将每个活动的开始时间和结束时间转换为事件
        events = []
        for i in range(n):
            start, end = startEnd[i]
            events.append((start, 1))  # 活动开始，+1主持人
            events.append((end, -1))  # 活动结束，-1主持人

        # 对事件按照时间排序，如果时间相同，先处理结束事件
        events.sort(key=lambda x: (x[0], x[1]))

        min_hosts = 0
        current_hosts = 0

        # 遍历所有事件，计算需要的主持人数
        for time, event in events:
            current_hosts += event
            min_hosts = max(min_hosts, current_hosts)

        return min_hosts
```

另一种解法：

```python
from typing import List
import heapq

class Solution:
    def minmumNumberOfHost(self, n: int, startEnd: List[List[int]]) -> int:
        # 按左端点从小到大排序
        startEnd.sort(key=lambda x: x[0])

        # 创建小顶堆
        q = []

        for i in range(n):
            if not q or q[0] > startEnd[i][0]:
                heapq.heappush(q, startEnd[i][1])
            else:
                heapq.heappop(q)
                heapq.heappush(q, startEnd[i][1])

        return len(q)
```



#### 6 覆盖连续区间

**在给定若干种硬币面值（每种无限供应）的前提下，选出最少数量的硬币，使得它们的组合能够表示出从 **1 到 X** 的所有整数值。

```python
import bisect

def solve():
    X, N = map(int, input().split())
    coins = list(map(int, input().split()))
    coins.sort()
    
    # 如果最小面值 > 1，无法凑出 1
    if coins[0] > 1:
        print(-1)
        return

    reach = 0
    ans = 0

    # 可以重复使用同一个面值多次，所以不移除
    while reach < X:
        target = reach + 1
        # 找 coins 中最大且 <= target
        idx = bisect.bisect_right(coins, target) - 1
        if idx < 0:
            print(-1)
            return
        c = coins[idx]
        reach += c
        ans += 1

    print(ans)

if __name__ == "__main__":
    solve()
```



## 单调栈

**单调栈的工作原理**

- **入栈操作**：当一个新的元素需要加入到栈中时，根据栈的性质（递增或递减），将所有不符合条件的栈顶元素弹出，然后再将新元素压入栈中。
- **出栈操作**：通常情况下，出栈操作是自动发生的，即在执行入栈操作时，为了保持栈的单调性，会自动移除不满足条件的栈顶元素。

**实现示例**

这里以一个简单的例子说明如何使用单调栈来解决问题。假设我们需要找到数组 `[4, 5, 2, 25]` 中每个元素右边第一个更大的数。

```python
def next_greater_element(nums):
    stack = []
    result = [0] * len(nums)
    
    for i in range(len(nums)):
        # 当栈不为空且当前考察的元素大于栈顶元素时
        while stack and nums[i] > nums[stack[-1]]:
            index = stack.pop()
            result[index] = nums[i]
        # 将当前元素的索引压入栈中
        stack.append(i)
    
    # 对于栈中剩余的元素，它们没有更大的元素
    while stack:
        index = stack.pop()
        result[index] = -1
    
    return result

nums = [4, 5, 2, 25]
print(next_greater_element(nums))  # 输出: [5, 25, 25, -1]
```

在这个例子中，我们维护了一个单调递减的栈，当遇到比栈顶元素大的数时，就找到了栈顶元素的“下一个更大的数”，然后将其从栈中弹出，并记录结果。最后，对于那些在栈中没有匹配到更大数的元素，它们的结果设置为 `-1`，表示没有更大的数。

```python
# 蒋子轩23工学院
def removeKDigits(num, k):
    stack = []  # 使用单调栈来保存结果数字
    
    for digit in num:  # 遍历原数字的每一位
        # 关键贪心策略：
        # 当还有删除次数(k>0) 且 栈不为空 且 栈顶数字大于当前数字时
        # 说明删除栈顶数字能让结果更小
        while k and stack and stack[-1] > digit:
            stack.pop()  # 弹出栈顶（删除较大的数字）
            k -= 1       # 删除次数减1
        
        stack.append(digit)  # 将当前数字入栈
    
    # 如果遍历完还有删除次数，说明前面没有足够的大数字可删除
    # 这时数字已经是非递减的，从尾部删除最大的k位
    while k:
        stack.pop()
        k -= 1
    
    return int(''.join(stack))  # 将栈中字符拼接成字符串再转成整数

# 输入处理
t = int(input())  # 测试用例数量
results = []     # 保存结果

for _ in range(t):
    n, k = input().split()  # 读取数字n和要删除的位数k
    results.append(removeKDigits(n, int(k)))  # 计算结果

# 输出结果
for result in results:
    print(result)
```

护林员盖房子

```python
def largest_rectangle_area(heights):
    """计算柱状图中的最大矩形面积"""
    stack = []  # 单调递增栈，存储(起始索引, 高度)
    # 栈中保持高度单调递增，这样遇到更低的柱子时可以计算前面的矩形面积
    max_area = 0  # 记录最大面积
    n = len(heights)  # 柱状图的柱子数量
    
    # 遍历每个柱子
    for i in range(n):
        start = i  # 记录当前柱子的起始位置
        
        # 关键：当栈不为空 且 栈顶柱子的高度 > 当前柱子高度
        # 说明遇到了一个更低的柱子，可以计算前面柱子的矩形面积了
        while stack and stack[-1][1] > heights[i]:
            index, height = stack.pop()  # 弹出栈顶元素，获取它的索引和高度
            
            # 计算以弹出柱子为高的矩形面积
            # 宽度 = 当前位置i - 柱子的起始索引index
            # 因为从index到i-1的位置，高度都>=height
            area = height * (i - index)
            max_area = max(max_area, area)  # 更新最大面积
            
            start = index  # 重要：当前柱子的起始位置更新为弹出柱子的起始位置
            # 因为当前柱子可以向左边扩展到弹出柱子的位置
        
        # 将当前柱子入栈
        # start记录了当前柱子能向左扩展的最远位置
        stack.append((start, heights[i]))
    
    # 处理栈中剩余的元素
    # 这些柱子的右边没有更低的柱子来限制它们
    for index, height in stack:
        # 这些柱子可以一直延伸到数组末尾
        area = height * (n - index)  # 宽度 = 总长度 - 起始索引
        max_area = max(max_area, area)
    
    return max_area


def maximal_rectangle(matrix):
    """计算二维矩阵中最大全0矩形面积"""
    if not matrix or not matrix[0]:  # 处理空矩阵
        return 0
    
    m, n = len(matrix), len(matrix[0])  # 行数和列数
    
    # heights数组：记录以当前行为底部的柱状图高度
    # heights[j] 表示从当前位置向上有多少个连续的0
    heights = [0] * n
    max_area = 0  # 记录全局最大面积
    
    # 逐行处理
    for i in range(m):
        # 更新当前行的柱状图高度
        for j in range(n):
            if matrix[i][j] == 0:  # 如果是空地
                heights[j] += 1  # 高度+1
            else:  # 如果是树木
                heights[j] = 0  # 高度重置为0（因为有树木就不能向上延伸）
        
        # 对当前行的柱状图计算最大矩形面积
        # 这个面积就是：以第i行为底边的最大矩形面积
        max_area = max(max_area, largest_rectangle_area(heights))
    
    return max_area


# 主程序
# 读取m行n列
m, n = map(int, input().split())
matrix = []  # 存储整个矩阵

# 读取m行数据
for _ in range(m):
    row = list(map(int, input().split()))  # 读取一行
    matrix.append(row)  # 添加到矩阵中

# 计算最大矩形面积
result = maximal_rectangle(matrix)
print(result)
```

接雨水

```python
def trap(height):
    n = len(height)
    if n < 3:
        return 0
    left, right = 0, n-1
    left_max, right_max = 0, 0
    total = 0
    
    while left < right:
        if height[left] < height[right]:
            if height[left] >= left_max:
                left_max = height[left]
            else:
                total += left_max - height[left]
            left += 1
        else:
            if height[right] >= right_max:
                right_max = height[right]
            else:
                total += right_max - height[right]
            right -= 1
    
    return total

# 读取输入
n = int(input())
height = list(map(int, input().split()))

# 计算并输出结果
print(trap(height))
```

五、「滑动窗口最大值」三者合一

```python
from collections import deque

def maxSlidingWindow(nums, k):
    dq = deque()  # 存下标，保证对应值递减
    res = []
    for right, x in enumerate(nums):
        # step 1: 窗口右扩，保持单调递减
        while dq and nums[dq[-1]] <= x:
            dq.pop()
        dq.append(right)

        # step 2: 移除滑出窗口的左端元素
        if dq[0] <= right - k:
            dq.popleft()

        # step 3: 当窗口形成（长度 >= k）时，记录最大值
        if right >= k - 1:
            res.append(nums[dq[0]])
    return res

```

六、前缀和优化区域统计(垃圾炸弹)

```python
def main():
    d = int(input().strip())
    n = int(input().strip())

    # 使用字典存储垃圾点，节省空间（稀疏数据时特别有效）
    moskow = {}
    max_coord = 1024
    min_coord = 0

    for _ in range(n):
        x, y, weight = map(int, input().strip().split())
        if (x, y) not in moskow:
            moskow[(x, y)] = 0
        moskow[(x, y)] += weight

    # 构建二维前缀和数组（只构建 [0..1024] 范围）
    size = max_coord + 1
    prefix = [[0] * (size + 1) for _ in range(size + 1)]  # prefix[0..1024+1][0..1024+1]

    for i in range(1, size + 1):
        for j in range(1, size + 1):
            # 注意：prefix[i][j] 对应坐标 (i-1, j-1)
            val = moskow.get((i - 1, j - 1), 0)
            prefix[i][j] = val + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]

    max_total = 0
    count = 0

    # 遍历所有可能的爆炸中心 (i, j)，范围 [0, 1024]
    for i in range(min_coord, max_coord + 1):
        for j in range(min_coord, max_coord + 1):
            # 计算爆炸影响区域 [x1, x2] × [y1, y2]
            x1 = max(min_coord, i - d)
            y1 = max(min_coord, j - d)
            x2 = min(max_coord, i + d)
            y2 = min(max_coord, j + d)

            # 查询前缀和：注意 prefix 是 1-indexed
            total = prefix[x2 + 1][y2 + 1] \
                    - prefix[x1][y2 + 1] \
                    - prefix[x2 + 1][y1] \
                    + prefix[x1][y1]

            if total > max_total:
                max_total = total
                count = 1
            elif total == max_total:
                count += 1

    print(count, max_total)


if __name__ == '__main__':
    main()
```

七、Kadane算法

Kadane 算法用于解决“**最大子数组和**”问题，即在一个整数数组中找到连续子数组的最大和。

```python
def kadane(arr):
    curr_max = total_max = arr[0]
    for x in arr[1:]:
        curr_max = max(x, curr_max + x)  # 要么重新开始，要么接上前面
        total_max = max(total_max, curr_max)
    return total_max
```

##### 2 扩展到二维 —— 最大子矩阵

将 Kadane 算法的思想扩展到二维：

**总体策略：**

1. 枚举所有可能的**上边界 `top`**
2. 对每个 `top`，枚举所有 `bottom >= top`
3. 对每一对 `(top, bottom)`，计算从第 `top` 行到第 `bottom` 行的**每列的累加和**，形成一个一维数组 `col_sum`
4. 在 `col_sum` 上运行 Kadane 算法，得到当前上下边界下的最大子矩阵和
5. 更新全局最大值

最大子矩阵

```python
def max_submatrix(matrix, n):
    def kadane(arr):
      	# max_ending_here 用于追踪到当前元素为止包含当前元素的最大子数组和。
        # max_so_far 用于存储迄今为止遇到的最大子数组和。
        max_end_here = max_so_far = arr[0]
        for x in arr[1:]:
          	# 对于每个新元素，我们决定是开始一个新的子数组（仅包含当前元素 x），
            # 还是将当前元素添加到现有的子数组中。这一步是 Kadane 算法的核心。
            max_end_here = max(x, max_end_here + x)
            max_so_far = max(max_so_far, max_end_here)
        return max_so_far

    max_sum = float('-inf')

    for top in range(n):
        temp_col_num = [0] * n
        for bottom in range(top, n):
            for col in range(n):
                temp_col_num[col] += matrix[bottom][col]
            max_sum = max(max_sum, kadane(temp_col_num))
    return max_sum

# 输入处理
import sys
data = sys.stdin.read().split()
n = int(data[0])
numbers = list(map(int, data[1:]))
matrix = [numbers[i * n:(i + 1) * n] for i in range(n)]

max_sum = max_submatrix(matrix, n)
print(max_sum)
```

八、前缀树Trie

```python
class Trie:

    def __init__(self):
        """
        初始化前缀树（Trie）
        使用嵌套字典结构存储节点
        每个节点是一个 dict，键为字符
        特殊键 "#" 表示一个单词的结束位置
        """
        self.root = {}             # Trie 的根节点，用字典表示
        self.end_of_word = "#"     # 特殊标记：表示该路径为一个单词的结束

    def insert(self, word: str) -> None:
        """
        将一个单词插入 Trie
        """
        node = self.root
        for char in word:
            # setdefault：若 char 存在返回已有节点；
            # 若不存在则创建一个空 dict 作为子节点并返回它
            node = node.setdefault(char, {})
        # 在单词末尾添加结束标记
        node[self.end_of_word] = self.end_of_word

    def search(self, word: str) -> bool:
        """
        判断一个完整单词是否在 Trie 中
        """
        node = self.root
        for char in word:
            # 如果任意字符不存在，说明该单词不存在
            if char not in node:
                return False
            node = node[char]
        # 需要检查结束标记，确保是完整单词而不是前缀
        return self.end_of_word in node

    def startsWith(self, prefix: str) -> bool:
        """
        判断是否存在以 prefix 为前缀的单词
        """
        node = self.root
        for char in prefix:
            # 若路径中缺字符，则没有这个前缀
            if char not in node:
                return False
            node = node[char]
        # 只需前缀完整，无需检查结束标记
        return True


if __name__ == "__main__":
    trie = Trie()
    trie.insert("apple")
    print(trie.search("apple"))   # True，完整单词
    print(trie.search("app"))     # False，只有前缀不是完整单词
    print(trie.startsWith("app")) # True，有单词以 app 开头
    trie.insert("app")
    print(trie.search("app"))     # True，此时 app 已插入
```

电话号码

```python
t = int(input())
for _ in range(t):
 n = int(input())
 nums = [input().strip() for _ in range(n)]
 nums.sort()                           # 字典序排序

 ok = True
 for i in range(n-1):
     # 如果前一个是后一个的前缀 → 冲突
     if nums[i+1].startswith(nums[i]):
         ok = False
         break

 print("YES" if ok else "NO")

```

拓扑排序——难，跳过

### week11-12 dp

```python
def make_change_4(coin_value_list, change, min_coins, coins_used):
    """
    动态规划求解找零问题
    参数:
        coin_value_list: 可用硬币面值列表
        change: 需要找零的金额
        min_coins: 用于存储每个金额所需最少硬币数的列表
        coins_used: 用于存储每个金额最后使用的硬币面值列表
    返回值:
        找零金额所需的最少硬币数
    """
    # 遍历从0到需要找零金额的所有可能金额
    for cents in range(change + 1):
        # 初始假设：使用1分硬币找零，需要的硬币数就是金额数
        coin_count = cents
        # 默认使用1分硬币
        new_coin = 1
        
        # 遍历所有小于等于当前金额的硬币面值
        for j in [c for c in coin_value_list if c <= cents]:
            # 如果使用硬币j可以找到更少的硬币组合
            if min_coins[cents - j] + 1 < coin_count:
                # 更新最少硬币数
                coin_count = min_coins[cents - j] + 1
                # 记录使用的硬币面值
                new_coin = j
        
        # 存储当前金额的最少硬币数
        min_coins[cents] = coin_count
        # 存储当前金额最后使用的硬币
        coins_used[cents] = new_coin
    
    # 返回最终结果
    return min_coins[change]


def print_coins(coins_used, change):
    """
    根据coins_used列表打印使用的硬币组合
    参数:
        coins_used: 存储每个金额最后使用硬币的列表
        change: 需要找零的金额
    """
    coin = change
    # 从目标金额开始，回溯找出所有使用的硬币
    while coin > 0:
        # 获取当前金额对应的硬币
        this_coin = coins_used[coin]
        # 打印硬币面值
        print(this_coin, end=" ")
        # 减去已使用的硬币面值，继续找剩余金额
        coin = coin - this_coin
    print()  # 换行


def main():
    """主函数"""
    # 需要找零的金额
    amnt = 63
    # 可用的硬币面值
    clist = [1, 5, 10, 21, 25]
    
    # 初始化两个列表，长度都是amnt+1
    # coins_used用于记录每个金额最后使用的硬币
    coins_used = [0] * (amnt + 1)
    # coin_count用于记录每个金额所需的最少硬币数
    coin_count = [0] * (amnt + 1)
    
    # 输出结果
    print(
        "Making change for {} requires the following {} coins: ".format(
            amnt, 
            make_change_4(clist, amnt, coin_count, coins_used)  # 调用函数计算最少硬币数
        ),
        end="",
    )
    # 打印具体使用的硬币组合
    print_coins(coins_used, amnt)
    
    # 打印coins_used列表，展示每个金额对应的最后使用硬币
    print("The used list is as follows:")
    print(coins_used)


# 程序入口
main()
```

找出最少零钱组合问题可以被视为一个<mark>完全背包</mark>问题的变种，具体来说，它是一个“完全背包”问题的最优解问题。下面我将详细解释这个问题的背景和解决方法。

**完全背包问题**

完全背包问题是一种背包问题，其中<mark>每种物品可以无限次选择</mark>。在最少零钱组合问题中，每种面额的硬币可以无限次使用，因此它可以被视为一个完全背包问题。

**代码实现**

```python
def min_coins_for_change(amount, coins):
    # 初始化 dp 数组，dp[i] 表示组成金额 i 所需的最少硬币数
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # 组成金额 0 所需的硬币数为 0

    # 遍历每个金额 i
    for i in range(1, amount + 1):
        # 遍历每个硬币面额 coin
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)

    # 返回结果
    return dp[amount] if dp[amount] != float('inf') else -1

# 示例
amount = 11
coins = [1, 2, 5]
print(min_coins_for_change(amount, coins))  # 输出 3 (5 + 5 + 1)
```

**时间复杂度**

- 时间复杂度为 O(n * m)，其中 n 是金额 `amount`，m 是硬币面额的数量。
- 空间复杂度为 O(n)，因为我们使用了一个长度为 `amount + 1` 的 `dp` 数组。

#### 2 动态规划的递归写法和递推写法

斐波那契数列——递归

```python
def f(n):
    if n <= 2:
        return 1
    else:
        return f(n-1)+f(n-2)


n = int(input())
ans = []
for _ in range(n):
    num = int(input())
    ans.append(f(num))

print('\n'.join(map(str, ans)))
```

三角数组

```python
# 输入三角形行数
N = int(input())
# 初始化三角形数组
tri = []
for _ in range(N):
    # 读取每一行的数字，转换为整数列表
    tri.append([int(i) for i in input().split()])

# 创建dp数组，dp[i][j]表示从(i,j)出发到底部的最大路径和
dp = [[0] * N for _ in range(N)]

# 初始化最后一行：从最后一行出发到底部的最大路径和就是该位置本身的值
for j in range(N):
    dp[N-1][j] = tri[N-1][j]

# 自底向上递推：从倒数第二行开始向上计算
for i in range(N-2, -1, -1):  # 从N-2行到0行
    for j in range(i+1):  # 第i行有i+1个元素
        # 状态转移方程：当前位置的值 + 下一行相邻两个位置的最大值
        dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + tri[i][j]

# 最终结果：从顶部(0,0)出发到底部的最大路径和
print(dp[0][0])
```

寻找最大子数组

```python
n = int(input())
*a, = map(int, input().split())

dp = [0]*n
dp[0] = a[0]

for i in range(1, n):
    dp[i] = max(dp[i-1]+a[i], a[i])

print(max(dp))
```

此处顺便介绍无后效性的概念。**状态的无后效性**是指：当前状态记录了历史信息，一旦当前状态确定，就不会再改变，且未来的决策只能在已有的一个或若干个状态的基础上进行，历史信息只能通过已有的状态去影响未来的决策。而针对上面的问题来说，<mark>每次计算状态 dp[i]，都只会涉及dp[i-1]</mark>，而不直接用到 dp[i-1]蕴含的历史信息。

```python
n = int(input())  # 输入数组长度
*a, = map(int, input().split())  # 输入数组元素

# dp[i] 表示以第i个元素结尾的最大子数组和
dp = [0] * n
# start[i] 表示以第i个元素结尾的最大子数组的起始位置
start = [0] * n
# 初始化：以第一个元素结尾的最大子数组就是它自己
dp[0] = a[0]

# 动态规划
for i in range(1, n):
    # 如果前一个位置的最大子数组和非负
    if dp[i-1] >= 0:
        # 可以接上前面的子数组
        dp[i] = dp[i-1] + a[i]
        # 起始位置不变
        start[i] = start[i-1]
    else:
        # 前一个位置的最大子数组和为负，重新开始
        dp[i] = a[i]
        # 起始位置就是当前位置
        start[i] = i

# 找到所有以i结尾的子数组和中的最大值
max_val = max(dp)
# 找到这个最大值对应的结束位置
pos = dp.index(max_val)

# 输出：最大和，起始位置，结束位置
# 注意：题目通常使用1-based索引，所以+1
print(max_val, start[pos]+1, pos+1)
```

**为什么说 Kadane 算法是 DP？**

Kadane 算法用于解决 **最大子数组和问题（Maximum Subarray Problem）**：给定一个整数数组，找出其中<mark>连续子数组的元素和的最大值</mark>。

它的核心思想符合动态规划的两个关键特征：

1. **最优子结构（Optimal Substructure）**
   全局最优解可以通过局部最优解构造出来。 
   - 定义 `dp[i]` 表示以第 `i` 个元素结尾的最大子数组和。
   - 那么状态转移方程为： $$ dp[i] = \max(dp[i-1] + a[i],\ a[i]) $$ 即：要么把当前元素加入前面的子数组，要么从当前元素重新开始。
2. **重叠子问题（Overlapping Subproblems）**
   计算 `dp[i]` 时会重复用到 `dp[i-1]` 的结果，因此可以用递推方式高效求解。

```python
def kadane(arr):
    # 初始化：
    # max_current: 以当前位置结尾的最大子数组和
    # max_global: 全局最大子数组和
    max_current = max_global = arr[0]
    
    # 从第二个元素开始遍历数组
    for i in range(1, len(arr)):
        # 关键选择：以当前位置结尾的最大子数组和
        # 两种选择：
        # 1. 从当前位置重新开始一个新子数组：arr[i]
        # 2. 将当前元素加入前一个子数组：max_current + arr[i]
        # 取两者中较大的
        max_current = max(arr[i], max_current + arr[i])
        
        # 更新全局最大值
        # 比较当前子数组和与已知的最大和
        max_global = max(max_global, max_current)
    
    return max_global
```

最长递增子序列

```python
n = int(input())
*b, = map(int, input().split())
dp = [1] * n  # dp[i]表示以b[i]结尾的最长递增子序列长度，初始每个元素自己长度为1

for i in range(1, n):  # 遍历每个元素
    for j in range(i):  # 遍历i之前的所有元素
        if b[j] < b[i]:  # 如果之前的元素比当前元素小，可以构成递增序列
            # 状态转移：以b[i]结尾的LIS长度 = max(当前值, 以b[j]结尾的长度+1)
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))  # 取所有dp[i]中的最大值
```

bisect用法

```python
import bisect
n = int(input())
*lis, = map(int, input().split())

# dp数组：用于维护当前找到的最小末尾元素
# 初始化为一个大数（1e9表示无穷大）
dp = [1e9] * n

for i in lis:  # 遍历每个元素
    # bisect.bisect_left(dp, i)：
    # 在dp中找到第一个 >= i 的位置
    pos = bisect.bisect_left(dp, i)
    # 用当前元素i替换dp[pos]处的值
    dp[pos] = i

# 找到dp中第一个小于1e8的位置，就是LIS长度
# 注意：这里应该是1e9，但代码写成了1e8，可能是笔误
print(bisect.bisect_left(dp, 1e8))
```

拦截导弹

```python
import bisect
n = int(input())
*lis, = map(int, input().split())

# dp数组：用于维护当前找到的最小末尾元素
# 初始化为一个大数（1e9表示无穷大）
dp = [1e9] * n

for i in lis:  # 遍历每个元素
    # bisect.bisect_left(dp, i)：
    # 在dp中找到第一个 >= i 的位置
    pos = bisect.bisect_left(dp, i)
    # 用当前元素i替换dp[pos]处的值
    dp[pos] = i

# 找到dp中第一个小于1e8的位置，就是LIS长度
# 注意：这里应该是1e9，但代码写成了1e8，可能是笔误
print(bisect.bisect_left(dp, 1e8))
```

最大子序列

```python
input()
a = [int(x) for x in input().split()]

n = len(a)
dp = [0]*n

for i in range(n):
    dp[i] = a[i]
    for j in range(i):
        if a[j] < a[i]:
            dp[i] = max(dp[j]+a[i], dp[i])

print(max(dp))
```

### 5 背包DP

#### 5.1 0-1背包（每个物品选或者不选）

```python
# 动态规划之背包问题（算法图解书中例子实现）

#第一步建立网格(横坐标表示[0,c]整数背包承重):(n+1)*(c+1)
def knapsack(n, c, w, p):
    cell = [[0 for j in range(c+1)]for i in range(n+1)]
    for j in range(c+1):
        #第0行全部赋值为0，物品编号从1开始.为了下面赋值方便
        cell[0][j] = 0
    for i in range(1, n+1):
        for j in range(1, c+1):
            #生成了n*c有效矩阵，以下公式w[i-1],p[i-1]代表从第一个元素w[0],p[0]开始取。
            if j >= w[i-1]:
                cell[i][j] = max(cell[i-1][j], p[i-1] + cell[i-1][j - w[i-1]])
            else:
                cell[i][j] = cell[i-1][j]
    return cell


goodsnum, bagsize = map(int, input().split())
#goodsnum, bagsize = 3, 4
*value, = map(int, input().split())
*weight, = map(int, input().split())
#value, weight = [1500, 3000, 2000], [1, 4, 3]  # guitar, stereo, laptop

cell = knapsack(goodsnum, bagsize, weight, value)
print(cell[goodsnum][bagsize])
```



```python
# 输入物品数量和背包容量
n, b = map(int, input().split())

# 价格数组，price[0]占位不用，从price[1]到price[n]是每个物品的价格
price = [0] + [int(i) for i in input().split()]

# 重量数组，weight[0]占位不用，从weight[1]到weight[n]是每个物品的重量
weight = [0] + [int(i) for i in input().split()]

# 创建动态规划表
# bag[i][j] 表示：考虑前i个物品，背包容量为j时，能获得的最大价值
# 维度：(n+1)行 × (b+1)列
bag = [[0] * (b + 1) for _ in range(n + 1)]

# 动态规划填表
for i in range(1, n + 1):  # 遍历每个物品，从第1个到第n个
    for j in range(1, b + 1):  # 遍历背包容量，从1到b
        
        # 如果当前物品的重量不超过当前背包容量j
        if weight[i] <= j:
            # 两种选择，取最大值：
            # 1. 放入当前物品：price[i] + bag[i-1][j-weight[i]]
            #    - price[i]: 当前物品的价值
            #    - bag[i-1][j-weight[i]]: 考虑前i-1个物品，容量为j-weight[i]时的最大价值
            # 2. 不放入当前物品：bag[i-1][j]
            bag[i][j] = max(price[i] + bag[i-1][j-weight[i]], bag[i-1][j])
        else:
            # 当前物品太重，放不进背包，只能不放入
            bag[i][j] = bag[i-1][j]

# 输出结果：考虑所有n个物品，背包容量为b时的最大价值
print(bag[-1][-1])
```



#### 优化23421:《算法图解》小偷背包问题

从 **大到小更新**，总是基于“之前未包含当前物品的最优解”来更新新的状态，因此能保证每个物品在每次主循环中只会被计算一次。

```python
# 压缩矩阵/滚动数组 方法
N,B = map(int, input().split())
*p, = map(int, input().split())
*w, = map(int, input().split())

dp=[0]*(B+1)
for i in range(N):
    for j in range(B, w[i] - 1, -1):
        dp[j] = max(dp[j], dp[j-w[i]]+p[i])
            
print(dp[-1])
```

最长回文串问题

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n <= 1:
            return s

        # ---------- 第一部分：预处理所有回文子串（DP） ----------
        is_palindrome = [[False] * n for _ in range(n)]

        for right in range(n):
            for left in range(right + 1):
                if s[left] == s[right] and (right - left <= 1 or is_palindrome[left + 1][right - 1]):
                    is_palindrome[left][right] = True

        # ---------- 第二部分：扫描所有 (left, right) 求最长 ----------
        max_len = 1
        start = 0

        for left in range(n):
            for right in range(left, n):
                if is_palindrome[left][right] and (right - left + 1) > max_len:
                    max_len = right - left + 1
                    start = left

        return s[start:start + max_len]
```

### 5.2 完全背包（每种物品可以选0个-无限个）

```python
n, a, b, c = map(int, input().split())
dp = [0]+[float('-inf')]*n

for i in range(1, n+1):
    for j in (a, b, c):
        if i >= j:
            dp[i] = max(dp[i-j] + 1, dp[i])

print(dp[n])
```

## 5.3 多重背包（每个物品数量有上限）

最简单的思路是将多个同样的物品看成多个不同的物品，从而化为0-1背包。稍作优化：可以改善拆分方式，譬如将m个1拆成x_1,x_2,……,x_t个1，只需要这些x_i中取若干个的和能组合出1至m即可。最高效的拆分方式是尽可能拆成2的幂，也就是所谓“二进制优化”

```python
def max_muscle_gain(T, n, trainings):
    # 定义一个很大的负数作为无效值
    INF = -10 ** 9
    # INF表示"不可行"状态
    # 为什么用负数？因为我们要取max，负数会被过滤掉

    # 初始化 dp 数组
    # dp[i][j] 表示：考虑前i个训练组，花费恰好j分钟时的最大增肌量
    # 二维数组：(n+1)行 × (T+1)列
    dp = [[INF] * (T + 1) for _ in range(n + 1)]

    # 设置初始条件
    for i in range(n + 1):
        dp[i][0] = 0  # 时间为0时，增肌量为0
        # 注意：这是"恰好用0分钟"，当然是可行的，增肌量为0

    # 动态规划转移
    for i in range(1, n + 1):  # 遍历每个训练组
        ti, wi = trainings[i - 1]  # 第i个训练组的时间和增肌量
        
        for j in range(T + 1):  # 遍历所有可能的时间
            # 情况1：不选择第i个训练组
            dp[i][j] = dp[i - 1][j]
            
            # 情况2：如果时间足够，选择第i个训练组
            if j >= ti:
                # dp[i-1][j-ti] + wi 表示：
                # 在前i-1个训练组中花费j-ti分钟的最大增肌量 + 当前训练组的增肌量
                # 必须用dp[i-1]而不是dp[i]，确保每个训练组只用一次
                dp[i][j] = max(dp[i][j], dp[i - 1][j - ti] + wi)

    # 输出结果
    if dp[n][T] < 0:
        return -1  # 如果结果为负数，说明不可行
    else:
        return dp[n][T]  # 考虑所有n个训练组，恰好用T分钟的最大增肌量
```

### 6 最长公共子串Longest common substring

```python
while True:
    try:
        # 读取一行输入，包含两个字符串，用空格分隔
        a, b = input().split()
    except EOFError:
        # 当没有更多输入时退出循环
        break
    
    # 获取两个字符串的长度
    alen = len(a)
    blen = len(b)
    
    # 创建动态规划表
    # dp[i][j] 表示字符串a的前i个字符和字符串b的前j个字符的最长公共子序列长度
    # 行数: alen+1 (0~alen)
    # 列数: blen+1 (0~blen)
    dp = [[0]*(blen+1) for i in range(alen+1)]

    # 动态规划填表
    for i in range(1, alen+1):        # 遍历字符串a的每个字符
        for j in range(1, blen+1):    # 遍历字符串b的每个字符
            if a[i-1] == b[j-1]:
                # 如果当前字符相等，公共子序列长度可以在之前的基础上+1
                # 注意：dp的i,j对应字符串的i-1,j-1索引
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                # 如果当前字符不相等，取两种可能情况的最大值：
                # 1. 不使用a的当前字符: dp[i-1][j]
                # 2. 不使用b的当前字符: dp[i][j-1]
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    # 输出结果：整个字符串a和b的最长公共子序列长度
    print(dp[alen][blen])
```

优化版本

```python
n = int(input())
li = list(map(int, input().split()))

# 初始化：单个元素，长度为1，上升和下降都算1
dpup = 1   # 当前结尾为“上升”的最长摆动序列长度
dpdo = 1   # 当前结尾为“下降”的最长摆动序列长度

for i in range(1, n):
    if li[i] > li[i-1]:
        dpup = max(dpdo + 1, dpup)   # 上升：接在下降后面
        # dpdo 不变
    elif li[i] < li[i-1]:
        dpdo = max(dpup + 1, dpdo)   # 下降：接在上升后面
        # dpup 不变
    # 如果相等，两者都不变

print(max(dpup, dpdo))
```

红蓝玫瑰、打家劫舍。

```python
n = int(input())
num = 0
stus = []
for _ in range(n):
    num += 1
    a, b, c = map(int, input().split())
    d = a + b + c
    stus.append((d, a, num))
stus.sort(key=lambda x: (-x[0], -x[1], x[2]))
for i in range(5):
    print(stus[i][2], stus[i][0])
```

```python
n, m = map(int, input().split())
prices = list(map(int, input().split()))

# 统计水果出现次数
fruit_count = {}
for _ in range(m):
    fruit = input().strip()
    fruit_count[fruit] = fruit_count.get(fruit, 0) + 1

# 水果数量列表
counts = sorted(fruit_count.values(), reverse=True)

# 价格排序
prices_sorted_asc = sorted(prices)
prices_sorted_desc = sorted(prices, reverse=True)

# 计算最小和最大总价
min_price = 0
max_price = 0

for i in range(len(counts)):
    min_price += counts[i] * prices_sorted_asc[i]
    max_price += counts[i] * prices_sorted_desc[i]

print(min_price, max_price)
```

```python
# 读取单词数量 N
N = int(input().strip())
# 读取四块积木，每块积木是一个包含6个大写字母的字符串
blocks = []
for _ in range(4):
    blocks.append(input().strip())
# 处理每一个待拼写的单词
for _ in range(N):
    word = input().strip()  # 读取当前单词
    n = len(word)  # 单词长度
    # 回溯函数：尝试用未使用的积木匹配单词的第idx个字母
    def backtrack(idx, used_blocks):
        # 如果已经匹配完单词所有字母，说明可以拼出这个单词
        if idx == n:
            return True
        # 遍历每一块积木
        for i in range(4):
            # 如果这块积木还没被使用，并且它包含当前需要的字母
            if not used_blocks[i] and word[idx] in blocks[i]:
                used_blocks[i] = True  # 标记为已使用
                # 递归尝试匹配下一个字母
                if backtrack(idx + 1, used_blocks):
                    return True
                used_blocks[i] = False  # 回溯，取消标记
        return False  # 所有尝试都失败，无法匹配

    # 初始化使用标记，开始从单词第一个字母匹配
    if backtrack(0, [False] * 4):
        print("YES")
    else:
        print("NO")
```

assignment

摆动序列

```python
#这个是AI写的，轻松AC，学到了
n = int(input())
nums = list(map(int, input().split()))
up = 1
down = 1
for i in range(1, len(nums)):
    if nums[i] > nums[i-1]:
        up = down + 1
    elif nums[i] < nums[i-1]:
        down = up + 1
print(max(up, down))
```

### M04147汉诺塔问题(Tower of Hanoi)

dfs, http://cs101.openjudge.cn/pctbook/M04147

思路：按照题目的提示形式化地写了代码，递归的妙处还是得多多做题领会。

耗时：20min（因为第一次接触相关题型，所以借助了AI）

代码

```python
data = input().split()
n = int(data[0])
a, b ,c = data[1], data[2], data[3]
disk = [str(i) for i in range(1, n + 1)]
def hanoi(n, start, now, end, disk):
    if n == 1:
        print(f"{disk[0]}:{start}->{end}")
    else:
        hanoi(n - 1, start, end, now, disk[:-1])
        print(f"{disk[-1]}:{start}->{end}")
        hanoi(n - 1, now, start, end, disk[:-1])
hanoi(n, a, b, c, disk)
```



### M46.全排列

backtracking, https://leetcode.cn/problems/permutations/

思路：路径化地实现这件事。先走一步，然后在这一步的基础上，再走一步，走到头了，再返回上个一个岔路口，直到遍历所有的路径。

耗时：15min



代码

```python
class Solution:
    def permute(self, nums):
        def backtrack(path, remaining):
            if not remaining:
                result.append(path)
                return
            for i in range(len(remaining)):
                backtrack(path + [remaining[i]], remaining[:i] + remaining[i + 1:])

        result = []
        backtrack([], nums)
        return result
```

### M018160: 最大连通域面积

dfs similar, http://cs101.openjudge.cn/pctbook/M18160

思路：用dfs，规定不同的搜索方向，搜过留痕。

耗时：20min

代码

```python
directions = {(-1, 0), (1, 0), (0, -1), (0, 1),(-1, 1), (1, -1), (1, 1), (-1, -1)}
def dfs(x, y):
    if not (0 <= x < N and 0 <= y < M) or grid[x][y] != 'W' or visited[x][y]:
        return 0
    visited[x][y] = True
    area = 1
    for dx, dy in directions:
        area += dfs(x + dx, y + dy)
    return area
T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    grid = [list(input().strip()) for _ in range(N)]
    visited = [[False] * M for _ in range(N)]
    max_area = 0
    for i in range(N):
        for j in range(M):
            if grid[i][j] == 'W' and not visited[i][j]:
                max_area = max(max_area, dfs(i, j))
    print(max_area)

```

### sy134: 全排列III 中等

https://sunnywhy.com/sfbj/4/3/134

思路：用backtrack，将不同的排列记入路径，挑选依据是跳过重复的部分。

耗时：15min

代码

```python
n = int(input())
nums = list(map(int, input().split()))
result = []
path = []
used = [False] * n
def backtrack():
    if len(path) == n:
        result.append(path[:])
        return
    for i in range(n):
        if used[i]:
            continue
        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:
            continue
        used[i] = True
        path.append(nums[i])
        backtrack()
        path.pop()
        used[i] = False
backtrack()
for res in result:
    print(' '.join(map(str, res)))
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>

![image-20251117180312524](C:\Users\Katherine Lee\AppData\Roaming\Typora\typora-user-images\image-20251117180312524.png)



### sy136: 组合II 中等

https://sunnywhy.com/sfbj/4/3/136

思路：利用backtrack，一位一位地取。

耗时：10min

代码

```python
n, k = map(int, input().split())
nums = list(map(int, input().split()))
path = []
result = []
def backtrack(start, path):
    if len(path) == k:
        result.append(path[:])
        return
    for i in range(start, n):
        path.append(nums[i])
        backtrack(i + 1, path)
        path.pop()
backtrack(0, [])
for res in result:
    print(' '.join(map(str, res)))

```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>

![image-20251117181146066](C:\Users\Katherine Lee\AppData\Roaming\Typora\typora-user-images\image-20251117181146066.png)



### sy137: 组合III 中等

https://sunnywhy.com/sfbj/4/3/137


思路：还是利用backtrack，从升序数组中一位一位地取，跳过重复元素。输出天然正序。

耗时：15min

代码

```python
n, k = map(int, input().split())
nums = list(map(int, input().split()))
nums.sort()
result = []
path = []
def backtrack(start):
    if len(path) == k:
        result.append(path[:])
    for i in range(start, n):
        if i > start and nums[i] == nums[i - 1]:
            continue
        path.append(nums[i])
        backtrack(i + 1)
        path.pop()
backtrack(0)
for res in result:
    print(' '.join(map(str, res)))
```

### M04123: 马走日

dfs, http://cs101.openjudge.cn/pctbook/M04123

思路：定义马可以走的方向，用dfs遍历，用True和False留痕。

耗时：20min

代码

```python
def tours(n, m, x, y):
    directions = {(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)}
    chess = [[False] * m for _ in range(n)]
    count = 0
    def dfs(x, y, step):
        nonlocal count
        if chess[x][y]:
            return
        chess[x][y] = True
        if step == n * m:
            count += 1
        else:
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    if not chess[nx][ny]:
                        dfs(nx, ny, step + 1)
        chess[x][y] = False
    dfs(x, y, 1)
    return count
T = int(input())
for _ in range(T):
    n, m, x, y = map(int, input().split())
    result = tours(n, m, x, y)
    print(result)
```

### LuoguP1255 数楼梯

dp, bfs, https://www.luogu.com.cn/problem/P1255

思路：迭代DP，最开始用了prev1, prev2, now 3个量，超时了，后来改成两个量就过了。

耗时：10min

代码：

```python
def solve(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n + 1):
        a, b = b, a + b
    return b
N = int(input())
print(solve(N))
```

### M5.最长回文子串

dp, two pointers, string, https://leetcode.cn/problems/longest-palindromic-substring/

思路：创建n * n的列表，用True & False来标定区间内的回文情况，左右双指针。

耗时：20min

代码：

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:    
        n = len(s)
        if n < 2:
            return s
        dp = [[False] * n for _ in range(n)]
        start, max_len = 0, 1
        for i in range(n):
            dp[i][i] = True
        for i in range(n - 1):
            if s[i] == s[i + 1]:
                dp[i][i + 1] = True
                start, max_len = i, 2
        for length in range(3, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                if s[i] == s[j] and dp[i + 1][j - 1]:
                    dp[i][j] = True
                    if length > max_len:
                        start, max_len = i, length
        return s[start:start + max_len]
```

### 474D. Flowers

dp, 1700 https://codeforces.com/problemset/problem/474/D

思路：从最后一位往前想，dp[i] = (dp[i - 1] + dp[i - k]) % MOD是全代码的核心环节， prefix和MOD是辅助功能，取模运算是可以在过程中同步进行的，不会影响结果。

耗时：40min

代码：

```python
MOD = 10 ** 9 + 7
import sys
def main():
    data = sys.stdin.read().split()
    t, k = int(data[0]), int(data[1])
    queries = []
    max_b = 0
    idx = 2
    for _ in range(t):
        a, b = int(data[idx]), int(data[idx + 1])
        idx += 2
        queries.append((a, b))
        max_b = max(max_b, b)
    if max_b == 0:
        for _ in queries:
            print(0)
        return
    dp = [0] * (max_b + 1)
    prefix = [0] * (max_b + 1)
    for i in range(max_b + 1):
        if i < k:
            dp[i] = 1
        else:
            dp[i] = (dp[i - 1] + dp[i - k]) % MOD
    prefix[0] = dp[0]
    for i in range(1, max_b + 1):
        prefix[i] = (prefix[i - 1] + dp[i]) % MOD
    for a, b in queries:
        total = (prefix[b] - prefix[a - 1]) % MOD
        if total < 0:
            total += MOD
        print(total)
if __name__ == "__main__":
    main()
```

### M198.打家劫舍

dp, https://leetcode.cn/problems/house-robber/

思路：此代码的核心在于dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])，也就是在“偷这家和上上家”和“偷上一家，不偷这家”之间，只能二选其一，此题的顺序是从第一家开始执行操作。不要考虑隔着三家都不偷的情况。

耗时：20min

代码：

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        n = len(nums)
        dp = [0] * n
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, n):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        return dp[n - 1]
```

几种dp的状态转移方程（先粗糙地整理一下，等多做一些题再好好领会）：

1.线性DP（一维序列）

```python
# dp[i]: 以第i个元素结尾的最长递增子序列长度
dp = [1] * n
for i in range(n):
    for j in range(i):
        if nums[j] < nums[i]:
            dp[i] = max(dp[i], dp[j] + 1)
# 答案: max(dp)
```

```python
# dp[i]: 以第i个元素结尾的最大子数组和
dp = [0] * n
dp[0] = nums[0]
for i in range(1, n):
    dp[i] = max(nums[i], dp[i-1] + nums[i])
# 答案: max(dp)
```

2.背包问题

```python
# dp[j]: 容量为j的背包能装的最大价值,01背包
dp = [0] * (capacity + 1)
for i in range(n):
    for j in range(capacity, weight[i]-1, -1):  # 倒序遍历
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
```

```python
# 物品无限取用
dp = [0] * (capacity + 1)
for i in range(n):
    for j in range(weight[i], capacity + 1):  # 正序遍历
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
```

3.区间dp

```python
# dp[i][j]: 第i到j个矩阵连乘的最小代价
dp = [[0] * n for _ in range(n)]
for length in range(2, n + 1):  # 区间长度
    for i in range(n - length + 1):
        j = i + length - 1
        dp[i][j] = float('inf')
        for k in range(i, j):  # 分割点
            cost = dp[i][k] + dp[k+1][j] + p[i]*p[k+1]*p[j+1]
            dp[i][j] = min(dp[i][j], cost)
```

4.树形dp

```python
#打家劫舍
def dfs(root):
    if not root: return [0, 0]
    # res[0]: 选当前节点的最大值
    # res[1]: 不选当前节点的最大值
    left = dfs(root.left)
    right = dfs(root.right)
    select = root.val + left[1] + right[1]      # 选当前，则子节点不能选
    not_select = max(left) + max(right)        # 不选当前，子节点可选可不选
    return [select, not_select]
```

### sy321迷宫最短路径

bfs, https://sunnywhy.com/sfbj/8/2/321

思路：从起点出发，用dist标记走到这里的距离，用pre标记是否途径。

耗时：25min

代码：

```python
from collections import deque
n, m = map(int, input().split())
migong = []
for _ in range(n):
    migong.append(list(map(int, input().split())))
directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
dist = [[-1] * m for _ in range(n)]
pre = [[None] * m for _ in range(n)]
queue = deque()
dist[0][0] = 0
queue.append((0, 0))
while queue:
    x, y = queue.popleft()
    if x == n - 1 and y == m - 1:
        break
    for dx, dy in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < n and 0 <= ny < m and dist[nx][ny] == -1 and migong[nx][ny] == 0:
            dist[nx][ny] = dist[x][y] + 1
            pre[nx][ny] = (x, y)
            queue.append((nx, ny))
path = []
cur = (n - 1, m - 1)
while cur is not None:
    path.append(cur)
    cur = pre[cur[0]][cur[1]]
path.reverse()
for x, y in path:
    print(x + 1, y + 1)
```

### sy324多终点迷宫问题

bfs, https://sunnywhy.com/sfbj/8/2/324

思路：和上题基本同理，这里需要输出所有终点的情况。

耗时：30min

代码：

```python
from collections import deque
n, m = map(int, input().split())
maze = []
for _ in range(n):
    maze.append(list(map(int, input().split())))
directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
dist = [[-1] * m for _ in range(n)]
if maze[0][0] == 1:
    for i in range(n):
        print(" ".join(str(-1) for _ in range(m)))
else:
    queue = deque()
    dist[0][0] = 0
    queue.append((0, 0))
    while queue:
        x, y = queue.popleft()
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < m:
                if maze[nx][ny] == 0 and dist[nx][ny] == -1:
                    dist[nx][ny] = dist[x][y] + 1
                    queue.append((nx, ny))
    for i in range(n):
        row_str = " ".join(str(dist[i][j]) for j in range(m))
        print(row_str)
```



### M02945: 拦截导弹

dp, greedy http://cs101.openjudge.cn/pctbook/M02945

思路：dp[i]表示以i开头的最长递减子列的长度。

耗时：15min

代码：

```python
k = int(input())
K = list(map(int, input().split()))
dp = [1] * k
for i in range(k):
    for j in range(i):
        if K[j] >= K[i]:
            dp[i] = max(dp[i], dp[j] + 1)
print(max(dp))
```

### 189A. Cut Ribbon

brute force/dp, 1300, https://codeforces.com/problemset/problem/189/A

思路：dp[n]表示n这个长度的ribbon所能切成的最大份数。

耗时：20min

代码：

```python
n, a, b, c = map(int, input().split())
dp = [-10**9] * (n + 1)
dp[0] = 0
for i in range(1, n + 1):
    if i >= a:
        dp[i] = max(dp[i], dp[i - a] + 1)
    if i >= b:
        dp[i] = max(dp[i], dp[i - b] + 1)
    if i >= c:
        dp[i] = max(dp[i], dp[i - c] + 1)
print(dp[n])
```

### M01384: Piggy-Bank

dp, http://cs101.openjudge.cn/practice/01384/

思路：这里要求装的钱尽量少，所以在dp环节取min。

耗时：25min

代码：

```python
T = int(input())
INF = 10 ** 9
for _ in range(T):
    e, f = map(int, input().split())
    n = int(input())
    coins = []
    for _ in range(n):
        p, w = map(int, input().split())
        coins.append([p, w])
    weight = f - e
    dp = [INF] * (weight + 1)
    dp[0] = 0
    for P, W in coins:
        for i in range(W, weight + 1):
            if dp[i - W] != INF:
                dp[i] = min(dp[i], dp[i - W] + P)
    if dp[weight] == INF:
        print("This is impossible.")
    else:
        print(f"The minimum amount of money in the piggy-bank is {dp[weight]}.")
```

### M27371:Playfair密码

simulation，string，matrix, http://cs101.openjudge.cn/practice/27371

思路：阅读了老师的写法，发现自己的算法有很多可优化之处。考试时replace操作等等是手搓的，整体WA了非常多次。

耗时：1h+

代码

```python
alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't','u', 'v', 'w', 'x', 'y', 'z']
keyword = list(str(input().strip()))
n = int(input().strip())
keyword_str = ''.join(keyword).lower().replace('j', 'i')
matrix_chars = []
seen = set()
for ch in keyword_str:
    if ch not in seen:
        seen.add(ch)
        matrix_chars.append(ch)
for ch in alphabet:
    if ch not in seen:
        seen.add(ch)
        matrix_chars.append(ch)
matrix = [[0] * 5 for _ in range(5)]
pos_map = {}  
for idx, ch in enumerate(matrix_chars):
    row = idx // 5
    col = idx % 5
    matrix[row][col] = ch
    pos_map[ch] = (row, col)
def encrypt_pair(a, b):
    r1, c1 = pos_map[a]
    r2, c2 = pos_map[b]
    if r1 == r2:
        a1 = matrix[r1][(c1 + 1) % 5]
        b1 = matrix[r2][(c2 + 1) % 5]
    elif c1 == c2: 
        a1 = matrix[(r1 + 1) % 5][c1]
        b1 = matrix[(r2 + 1) % 5][c2]
    else:
        a1 = matrix[r1][c2]
        b1 = matrix[r2][c1]
    return a1 + b1
for _ in range(n):
    text = input().strip().lower().replace('j', 'i')
    i = 0
    length = len(text)
    result_chars = []
    
    while i < length:
        a = text[i]
        if i + 1 < length:
            b = text[i + 1]
            if a == b:
                b = 'q' if a == 'x' else 'x'
                i += 1 
            else:
                i += 2  
        else:
            b = 'q' if a == 'x' else 'x'
            i += 1
        encrypted = encrypt_pair(a, b)
        result_chars.append(encrypted)
    print(''.join(result_chars))
```

